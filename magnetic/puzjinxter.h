/**
 *
 *    _    __        _      __                           
 *   | |  / /____   (_)____/ /_      __ ____ _ _____ ___ 
 *   | | / // __ \ / // __  /| | /| / // __ `// ___// _ \
 *   | |/ // /_/ // // /_/ / | |/ |/ // /_/ // /   /  __/
 *   |___/ \____//_/ \__,_/  |__/|__/ \__,_//_/    \___/ 
 *                                                       
 *  Copyright (©) Voidware 2016-2017.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS," WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 * 
 *  contact@voidware.com
 */

// included from puzzle.cpp
#include "puzzle.h"
// rooms.h file generated by fred23
#include "roomsjinxter.h"

#define JDEF_READER(_name)                                               \
struct J ## _name ## Puzzle : public Puzzle                                  \
{                                                                       \
    J ## _name ## Puzzle() : Puzzle(#_name) {}                               \
    void run() override                                                 \
    {   if (state(0,1))                                                 \
          text("Maybe [read the " #_name "](read the " #_name ").", 1); \
    }                                                                   \
};

JDEF_READER(document)
JDEF_READER(book)
JDEF_READER(note)
JDEF_READER(letter)
JDEF_READER(notice)

struct JButtonPuzzle: public Puzzle
{
    JButtonPuzzle() : Puzzle("button") {}

    void run() override
    {
        text("Maybe [press the button](press button).");
    }
};

static uchar* symRingCount()
{
     static int addr;
     if (!addr) addr = get_sym_value("RingCount");
     assert(addr);
     return getcode() + addr;
}

struct JPhonePuzzle: public Puzzle
{
    string pnumber = "";
    string youdial = "You are dialing ";

    JPhonePuzzle() : Puzzle("telephone") {}

    void action(int act) override
    {
        switch (act)
        {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
            pnumber = pnumber + std::to_string(act%10);
            text((youdial+std::to_string(act%10)+".").c_str(),2);
            _res = true;
            break;
        case 11:
            pnumber = "";
            text("You hung up.",1);
            _res = true;
            break;
        case 22:
            _action("dial "+pnumber,1);
            pnumber = "";
            break;
        }
    }

    void run() override
    {
        uchar* ringCount = symRingCount();
        LOG4("Puzzle phone -> ringcount:  ", (unsigned int)*ringCount);
        if (*ringCount != 0x00)
        {
            if (state(0,1))
            {
                text("Maybe [answer](answer phone) the phone.", 1);
            }
        }
        else
        {
            if (state(0,1))
            {
                text("Well, it's phone, so maybe dial a number: [Abort](do telephone 11)   [0](do telephone 10)   [1](do telephone 1)   [2](do telephone 2)   [3](do telephone 3)   [4](do telephone 4) "
                     " [5](do telephone 5)   [6](do telephone 6)   [7](do telephone 7)   [8](do telephone 8)   [9](do telephone 9)   [Dial](do telephone 22)",1);
                pnumber = "";
            }
        }
    }
};

struct JFridgePuzzle: public Puzzle
{
    JFridgePuzzle() : Puzzle("fridge") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem fridge("fridge");
            if (fridge.isClosed())
                text("Maybe [open the fridge](open the fridge).",1);
            else if (fridge.isOpen())
                text("Maybe [close the fridge](close the fridge).",1);
        }
    }
};

struct JMailboxPuzzle: public Puzzle
{
    JMailboxPuzzle() : Puzzle("mailbox") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem mailbox("mailbox");
            if (mailbox.isClosed())
                text("Maybe [open](open the mailbox) the mailbox.",1);
            else if (mailbox.isOpen())
                text("Maybe [close](close the mailbox) the mailbox.",1);
        }
    }
};

struct JMagpiePuzzle: public Puzzle
{
    JMagpiePuzzle() : Puzzle("magpie") {}

    void run() override
    {
        if (state(0,1))
        {
            text("Maybe [listen](listen to magpie) to the magpie.", 1);
        }
    }
};

struct JTrapPuzzle: public Puzzle
{
    JTrapPuzzle() : Puzzle("mouse mousetrap") {}

    void run() override
    {
        if (state(0,1))
        {
            text("Maybe [set](set the trap) the trap.", 1);
        }
    }
};

struct JMatchboxPuzzle: public Puzzle
{
    JMatchboxPuzzle() : Puzzle("match box") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem matchbox("match box");
            if (matchbox.carried())
            {
                if (matchbox.isClosed())
                {
                    text("Maybe [open](open the match box) the match box.", 1);
                }
                else
                {
                    text("Maybe [take](take match from match box) a match from the box or [close](close the match box) the box.", 1);
                }
            }
        }
    }
};

struct JMatchPuzzle: public Puzzle
{
    JMatchPuzzle() : Puzzle("match") {}

    void action(int act) override
    {
        switch (act)
        {
        case 1:
            IItem match("match");
            if (!match.simplyCarried())
            {
                // we need to take a match specificially from the box,
                // otherwise we might pick up a burnt one that we dropped
                // before
                _action("take match from box",act);
            }
            _action("light match ",act);
            break;
        }
    }

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [light](do match 1) a match.", 1);
        }
    }
};

struct JMilkPuzzle: public Puzzle
{
    JMilkPuzzle() : Puzzle("milk") {}

    void run() override
    {
        IItem milk("milk");
        if (milk.carried())
        {
            if (state(0,1))
            {
                text("Maybe [drink the milk](drink milk).",1);
            }
        }
    }
};

static uchar* symCanoeLaunched()
{
     static int addr;
     if (!addr) addr = get_sym_value("CanoeLaunched");
     assert(addr);
     return getcode() + addr;
}

struct JCanoePuzzle: public Puzzle
{
    JCanoePuzzle() : Puzzle("canoe") {}

    void run() override
    {
        uchar* canoeLaunched = symCanoeLaunched();
        LOG4("Puzzle canoe -> canoeLaunched:  ", (unsigned int)*canoeLaunched);
        if (*canoeLaunched == 0x00)
        {
            if (state(0,1))
            {
                text("Maybe [put the canoe in the water](put canoe in water).", 1);
            }
        }
        else
        {
            if (state(0,1))
            {
                LOG3("player on ", get_object_player_on());
                IItem ploc(find_item(get_object_player_on()));
                if (ploc && ploc == has("canoe"))
                {
                   text("maybe [get off](get off canoe) the canoe");
                }
                else
                {
                   text("Maybe [enter](enter the canoe) the canoe.",1);
                }
            }
        }
    }
};

struct JDirtPuzzle: public Puzzle
{
    JDirtPuzzle() : Puzzle("mound of dirt") {}

    void run() override
    {
        if (state(0,1))
        {
            text("Maybe [dig](dig in the dirt) in the dirt.", 1);
        }
    }
};

struct JCanOfWormsPuzzle: public Puzzle
{
    JCanOfWormsPuzzle() : Puzzle("can of worms") {}

    void run() override
    {
        if (state(0,1) )
        {
            IItem can("can of worms");
            IItem opener("tin opener");
            if (can.carried() && opener.carried() && can.isClosed())
            {
                 text("Maybe [open](open can of worms with tin opener) the can with the tin opener.", 1);
            }
        }
    }
};

struct JAirlockHatchPuzzle: public Puzzle
{
    JAirlockHatchPuzzle() : Puzzle("airlock hatch") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem airlock("airlock hatch");
            if (airlock.isClosed())
            {
                text("Maybe [open](open the airlock hatch) the hatch.", 1);
            }
            else
            {
                text("Maybe [enter](enter airlock hatch) the hatch or [close](close the airlock hatch) it.", 1);
            }
        }
    }
};


// Perhaps add the press op to the button description directly
struct JLeftButtonPuzzle: public Puzzle
{
    JLeftButtonPuzzle() : Puzzle("left button") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [press](press left button) the left button.", 1);
        }
    }
};

struct JRightButtonPuzzle: public Puzzle
{
    JRightButtonPuzzle() : Puzzle("right button") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [press](press right button) the right button.", 1);
        }
    }
};

struct JWheelPuzzle: public Puzzle
{
    JWheelPuzzle() : Puzzle("large wheel") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [turn](turn large wheel) the wheel.", 1);
        }
    }
};

static uchar* symUnderWater()
{
     static int addr;
     if (!addr) addr = get_sym_value("UnderWater");
     assert(addr);
     return getcode() + addr;
}

struct JChandelierPuzzle: public Puzzle
{
    JChandelierPuzzle() : Puzzle("chandelier") {}

    void run() override
    {
        uchar* underWater = symUnderWater();
        LOG4("Puzzle chandlier -> underWater:  ", (unsigned int)*underWater);
        if (*underWater != 0x00 && get_current_room() == JRLIBRARY2)
        {
            if (state(0,1))
            {
                text("Maybe [swim up](go up) to the reach the chandelier.", 1);
            }
        }
    }
};

static uchar* symAppliedForJob()
{
     static int addr;
     if (!addr) addr = get_sym_value("AppliedForJob");
     assert(addr);
     return getcode() + addr;
}

struct JBakerPuzzle: public Puzzle
{
    JBakerPuzzle() : Puzzle("baker") {}

    void run() override
    {
        uchar* appliedForJob = symAppliedForJob();
        LOG4("Puzzle baker -> appliedForJob:  ", (unsigned int)*appliedForJob);
        if (*appliedForJob == 0x00)
        {
            if (state(0,1))
            {
                text("Maybe [ask the baker for a job](ask the baker for a job).", 1);
            }
        }
    }
};

struct JOvenPuzzle: public Puzzle
{
    JOvenPuzzle() : Puzzle("oven") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem oven("oven");
            if (oven.isClosed())
            {
                 text("Maybe [open](open the oven) the oven.", 1);
            }
            else
            {
                IItem pc("pelican charm");
                if (pc.carried())
                {
                    text("You certainly don't want to [climb](climb into oven) into the oven, but maybe [close](close the oven) it.", 1);
                }
                else
                {
                    text("Maybe [close](close the oven) the oven.", 1);
                }
            }
        }
    }
};

struct JBreadPuzzle: public Puzzle
{
    JBreadPuzzle() : Puzzle("bread") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [eat](eat bread) the bread.", 1);
        }
    }
};

struct JBeerPuzzle: public Puzzle
{
    JBeerPuzzle() : Puzzle("beer") {}

    void run() override
    {
        IItem coin = has("one ferg coin");
        if (coin && state(0,1))
        {
             text("Maybe [buy a beer](buy beer with coin) with the coin.", 1);
        }
    }
};

#define JDEF_HANDLE(_pname,_iname)                                               \
struct J ## _pname ## Puzzle : public Puzzle                                  \
{                                                                       \
    J ## _pname ## Puzzle() : Puzzle(#_iname) {}                               \
    void run() override                                                 \
    {   if (state(0,1))                                                 \
          text("Maybe [turn the " #_iname "](turn the " #_iname ").", 1); \
    }                                                                   \
};

JDEF_HANDLE(TLHandle,top left handle)
JDEF_HANDLE(TRhandle,top right handle)
JDEF_HANDLE(BLHandle,bottom left handle)
JDEF_HANDLE(BRHandle,bottom right handle)

struct JClockmakersDoorPuzzle: public Puzzle
{
    JClockmakersDoorPuzzle() : Puzzle("clockmakers door") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [knock](knock on clockmakers door) on the door.", 1);
        }
    }
};

struct JStoolPuzzle: public Puzzle
{
    JStoolPuzzle() : Puzzle("stool") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [climb](climb on stool) onto the stool.", 1);
        }
    }
};

struct JLadderPuzzle: public Puzzle
{
    JLadderPuzzle() : Puzzle("ladder") {}

    void run() override
    {
        IItem ladder("ladder");
        IItem engine("engine");
        if (state(0,1))
        {
            if (!relatedTo(ladder,engine))
            {
                text("Maybe [climb](climb on ladder) onto the ladder.", 1);
            }
            else
            {
                text("Maybe [put](put ladder on shop) the ladder on the shop.", 1);
            }
        }
    }
};

struct JBeamPuzzle: public Puzzle
{
    JBeamPuzzle() : Puzzle("beam") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [climb](climb on beam) onto the beam.", 1);
        }
    }
};

struct JRainWeathermanPuzzle: public Puzzle
{
    JRainWeathermanPuzzle() : Puzzle("rain weatherman") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [hold](hold onto rain weatherman) onto the rain weatherman.", 1);
        }
    }
};

struct JHarmonicaPuzzle: public Puzzle
{
    JHarmonicaPuzzle() : Puzzle("harmonica") {}

    void run() override
    {
        IItem harmonica = has("harmonica");
        if (harmonica && state(0,1))
        {
             text("Maybe [play](play the harmonica) the harmonica.", 1);
        }
    }
};

struct JUnicornPuzzle: public Puzzle
{
    JUnicornPuzzle() : Puzzle("unicorn") {}

    void run() override
    {
         if (state(0,1))
         {
             LOG3("player on ", get_object_player_on());
             IItem ploc(find_item(get_object_player_on()));
             if (ploc && ploc == has("unicorn"))
             {
                text("maybe [dismount](dismount).");
             }
             else
             {
                text("Maybe [mount](mount the unicorn) the unicorn.",1);
             }
         }
    }
};

struct JBlockPuzzle: public Puzzle
{
    JBlockPuzzle() : Puzzle("plastic block") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe slide   [1](slide 1)   [2](slide 2)   [3](slide 3)   [4](slide 4)   [5](slide 5)   "
                  "[6](slide 6)   [7](slide 7)   [8](slide 8)   [9](slide 9) .", 1);
        }
    }
};

struct JCloudPuzzle: public Puzzle
{
    JCloudPuzzle() : Puzzle("cloud") {}

    void run() override
    {
        if (state(0,1))
        {
             text("Maybe [get on the cloud](get on the cloud) .", 1);
        }
    }
};

struct JCasePuzzle: public Puzzle
{
    JCasePuzzle() : Puzzle("case") {}

    void run() override
    {
         if (state(0,1) && (get_current_room() == JRON_PLATFORM || get_current_room() == JREND_OF_BEAM))
         {
             text("Maybe [take all](take all from case) from case.", 1);
         }
    }
};

struct JPuddlePuzzle: public Puzzle
{
    JPuddlePuzzle() : Puzzle("puddle") {}

    void run() override
    {
         if (state(0,1))
         {
             text("Maybe [get up](get up).", 1);
         }
    }
};

static uchar* symLoseTicketState()
{
     static int addr;
     if (!addr) addr = get_sym_value("LoseTicketState");
     assert(addr);
     return getcode() + addr;
}

struct JTicketPuzzle: public Puzzle
{
    JTicketPuzzle() : Puzzle("ticket") {}

    void run() override
    {
        IItem ticket = has("ticket");
        IItem oneferg("one ferg coin");
        IItem twoferg("two ferg coin");
        uchar* loseticket = symLoseTicketState();
        LOG4("Puzzle ticket -> looseticketstate:  ", (unsigned int)*loseticket);
         if ( !ticket.carried() && (*loseticket==0x00) && (state(0,1)))
         {
             if (twoferg.carried())
             {
                 text("Maybe [buy](buy ticket with two ferg coin) a ticket.", 1);
             }
             else if (oneferg.carried())
             {
                 text("Maybe [buy](buy ticket with one ferg coin) a ticket.", 1);
             }
         }
         else if (*loseticket != 0x00)
         {
             _action("get ticket",1);
             _res = false;
         }
    }
};

struct JTrainPuzzle: public Puzzle
{
    JTrainPuzzle() : Puzzle("train") {}

    void run() override
    {
        if (get_current_room() == JRPLATFORM_BRIDGE)
        {

            if (state(0,1))
            {
                text("Maybe [jump](jump onto the train) onto the train.", 1);
            }
        }
        else if (get_current_room() == JRPLATFORM1)
        {
            IItem ticket("ticket");
            if (state(0,1) && ticket.carried())
            {
                text("Maybe [enter](enter train) the train.", 1);
            }
        }
        else
        {
            IItem ticket("ticket");
            uchar* loseticket = symLoseTicketState();
            LOG4("Puzzle train -> looseticketstate:  ", (unsigned int)*loseticket);
             if ( ticket.carried() && (*loseticket==4))
             {
                 _action("run after train",1);
                 _res = false;
             }
        }

    }
};

struct JCWindowPuzzle: public Puzzle
{
    JCWindowPuzzle() : Puzzle("carriage window") {}

    void run() override
    {
         if ((get_current_room() == JRTRAIN_ROOF) && state(0,1))
         {
             text("Maybe [climb](climb window) the window.", 1);
         }
    }
};

struct JXAMPuzzle: public Puzzle
{
    JXAMPuzzle() : Puzzle("xam") {}

    void run() override
    {
        if (get_current_room() == JRDUNGEON)
        {
            if (state(0,1))
            {
                text("Maybe [wake](wake XAM) XAM.", 1);
            }
        }
    }
};

struct JRopePuzzle: public Puzzle
{
    JRopePuzzle() : Puzzle("rope") {}

    void run() override
    {
        IItem rope("rope");
        IItem manacles("manacles");
        if (rope.isExplored() && manacles.isExplored())
        {
            if (state(0,1))
            {
                text("Maybe [tie](tie the rope to the manacles) the rope to the manacles.", 1);
            }
        }
    }
};

struct JWalrusCharmPuzzle: public Puzzle
{
    JWalrusCharmPuzzle() : Puzzle("walrus charm") {}

    void run() override
    {
        IItem wc("walrus charm");
        IItem os("oojimy spell");
        if (wc.carried() && wc.isExplored())
        {
            os.setExplored(true);
        }
        else
        {
            os.setExplored(false);
        }
    }
};

struct JUnicornCharmPuzzle: public Puzzle
{
    JUnicornCharmPuzzle() : Puzzle("unicorn charm") {}

    void run() override
    {
        IItem uc("unicorn charm");
        IItem ws("watchercallit spell");
        if (uc.carried() && uc.isExplored())
        {
            ws.setExplored(true);
        }
        else
        {
            ws.setExplored(false);
        }
    }
};

struct JPelicanCharmPuzzle: public Puzzle
{
    JPelicanCharmPuzzle() : Puzzle("pelican charm") {}

    void run() override
    {
        IItem pc("pelican charm");
        IItem ds("doofer spell");
        if (pc.carried() && pc.isExplored())
        {
            ds.setExplored(true);
        }
        else
        {
            ds.setExplored(false);
        }

    }
};

struct JInnerHatchPuzzle: public Puzzle
{
    JInnerHatchPuzzle() : Puzzle("inner hatch") {}

    void run() override
    {
        IItem ih("inner hatch");
        if ( ih.isOpen())
        {
            _action("enter inner hatch",1);
            _res = false;
        }
    }
};

static uchar* symFlagFence()
{
     static int addr;
     if (!addr) addr = get_sym_value("FlagFence");
     assert(addr);
     return getcode() + addr;
}

static uchar* symFlagHoldFence()
{
     static int addr;
     if (!addr) addr = get_sym_value("FlagHoldFence");
     assert(addr);
     return getcode() + addr;
}

struct JFencePuzzle: public Puzzle
{
    JFencePuzzle() : Puzzle("fence") {}

    void run() override
    {
        uchar* flagFence = symFlagFence();
        uchar* flagHoldFence = symFlagHoldFence();
        if ( *flagFence == 0x00 )
        {
            IItem gloves = has("gloves");
            IItem secateurs = has("secateurs");
            if (*flagHoldFence == 0x00)
            {
                if (gloves.carried() && gloves.isWorn())
                {
                    if (state(0,1))
                    {
                        text("Maybe [hold](hold fence) the fence.", 1);
                    }
                }
                else if (secateurs.carried())
                {
                    if (state(0,1))
                    {
                        // perhaps remove this, this way the player has to find out by himself to wear the gloves...
                        text("Maybe [cut](cut fence with secateurs) the fence with the secateurs.", 1);
                    }
                }
            }
            else if (secateurs.carried())
            {
                if (state(0,1))
                {
                    text("Maybe [cut](cut fence with secateurs) the fence with the secateurs.", 1);
                }
            }
        }
    }
};

struct JTrainRoofPuzzle: public Puzzle
{
    JTrainRoofPuzzle() : Puzzle("roof") {}

    void run() override
    {
        if ((get_current_room() == JRTRAIN_ROOF) && state(0,1))
        {
            text("Maybe [lie down](lie down).", 1);
        }
    }
};
