/**
 *
 *    _    __        _      __                           
 *   | |  / /____   (_)____/ /_      __ ____ _ _____ ___ 
 *   | | / // __ \ / // __  /| | /| / // __ `// ___// _ \
 *   | |/ // /_/ // // /_/ / | |/ |/ // /_/ // /   /  __/
 *   |___/ \____//_/ \__,_/  |__/|__/ \__,_//_/    \___/ 
 *                                                       
 *  Copyright (©) Voidware 2016-2017.
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to
 *  deal in the Software without restriction, including without limitation the
 *  rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 *  sell copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS," WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 *  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 *  IN THE SOFTWARE.
 * 
 *  contact@voidware.com
 */

// included from puzzle.cpp
#include "puzzle.h"
// rooms.h file generated by fred23
#include "roomsguild.h"

struct JettyPuzzle: public Puzzle
{
    JettyPuzzle() : Puzzle("jetty") {}

    void run() override
    {
        if (get_current_room() == RNBOAT)
            text("Maybe [jump to the jetty](jump to the jetty).");
    }
};

struct OldManPuzzle: public Puzzle
{
    OldManPuzzle() : Puzzle("old man") {}

    void run() override
    {
        text("Maybe [help the old man](help the old man).");
    }
};

struct JunkPuzzle: public Puzzle
{
    JunkPuzzle() : Puzzle("junk") {}

    bool precondition() override
    {

        // junk room->moat
        return has(_name).isExplored() && !way(RNROOM2, RNPASSAGE3);
    }

    void run() override
    {
        text("Maybe [move the junk](move the junk).");
    }
};

struct CoalPuzzle: public Puzzle
{
    CoalPuzzle() : Puzzle("lump of coal") {}

    void run() override
    {
        IItem lump("lump of coal");
        if (lump.carried())
        {
            if (state(0,1))
            {
                text("Maybe [break the coal](break the coal).",1);
            }
        }
    }
};

struct LampPuzzle: public Puzzle
{
    LampPuzzle() : Puzzle("lamp") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem item("lamp");
            if (item.isLit())
                text("Maybe [turn off the lamp](turn off the lamp).", 1);
            else
                text("Maybe [light the lamp](light the lamp).", 1);
        }
    }
};

struct PipePuzzle: public Puzzle
{
    PipePuzzle() : Puzzle("pipe") {}

    bool precondition() override
    {
        IItem pipe(_name);

        // XX fix b6
        return pipe.isExplored() && pipe.loc_data() == 0xb6; // attached to drainage system.
    }

    void run() override
    {
        text("Maybe [pull the pipe](pull the pipe).");
    }
};

struct StopcockPuzzle: public Puzzle
{
    StopcockPuzzle() : Puzzle("stopcock") {}

    void run() override
    {
        IItem scock("stopcock");
        if (scock.isClosed())
            text("Maybe [open the stopcock](open the stopcock).");
        else if (scock.isOpen())
        {
            text("Maybe [close the stopcock](close the stopcock).");
        }
    }
};

#define DEF_READER(_name)                                               \
struct _name ## Puzzle : public Puzzle                                  \
{                                                                       \
    _name ## Puzzle() : Puzzle(#_name) {}                               \
    void run() override                                                 \
    {   if (state(0,1))                                                 \
          text("Maybe [read the " #_name "](read the " #_name ").", 1); \
    }                                                                   \
};

DEF_READER(blackboard);
DEF_READER(paperback);
DEF_READER(books);
DEF_READER(diary);
DEF_READER(notice);
DEF_READER(sign);

struct TreasurePuzzle: public Puzzle
{
    IItems _treasure;

    TreasurePuzzle(const char* name) : Puzzle(name) {}

    IItems& treasure()
    {
        static const char* tnames[] =
            {
                "plectrum",
                "chalice",
                "fossil",
                "oil painting",
                "ruby",
                "china pot",
                "brooch",
                "designer dress",
                "diamond ring",
                "plastic bag",
                "incense burner",
                "statuette",
                "chips",
                "gem",
                "ivory rhinoceros",
            };

        _treasure.clear();
        
        for (size_t i = 0; i < DIM(tnames); ++i)
        {
            IItem ii = has(tnames[i]);
            if (ii)
            {
                //LOG3("treasure includes ", ii)
                _treasure.push_back(ii);
            }
        }

        return _treasure;
    }

};

struct NightSafePuzzle: public TreasurePuzzle
{
    NightSafePuzzle() : TreasurePuzzle("safe") {}

    bool precondition() override
    {
        IItem safe = has(_name);
        if (safe && safe.isOpen())
        {
            if (treasure().size() > 0) return true;
        }
        return false;
    }

    void action(int act) override
    {
        switch (act)
        {
        case 1:
            {
                IItems t = treasure();
                for (size_t i = 0; i < t.size(); ++i)
                {
                    const IItem& ti = actIsoGet(t[i]);
                    if (ti)
                    {
                        string cmd = "put " + ti.tnWord() + " in night safe";
                        _action(cmd, act);
                        _action("close night safe", act);
                        _action("open night safe", act);
                    }
                }
            }
            break;
        }
    }

    void run() override
    {
        text("Maybe [put treasure in safe](do safe 1).");
    }
};
    
struct BarsPuzzle: public Puzzle
{
    BarsPuzzle() : Puzzle("bars") {}

    void run() override
    {
        text("Maybe try to [break the bars](break the bars) anyway.");
    }
};

struct BilliardsPuzzle: public Puzzle
{
    BilliardsPuzzle() : Puzzle("billiards") {}

    void action(int act) override
    {
        switch (act)
        {
        case 1:
            {
                actIsoGet("cue");
                _action("hit white ball towards red ball with cue", 0);
            }
            break;
        case 2:
            {
                actIsoGet("cue");
                _action("hit white ball towards spot ball with cue", 0);
            }
            break;
        }

        // even if didnt work (eg no cue), do not fall through to
        // default command (look).
        _res = true;
    }

    void run() override
    {
        text("Maybe [hit white ball towards red ball](do billiards 1) with cue, or [hit white ball towards spot ball](do billiards 2) with cue.");
    }
};

struct FishPuzzle: public Puzzle
{
    FishPuzzle() : Puzzle("fish") {}

    void action(int act) override
    {
        switch (act)
        {
        case 1:
            actGet("cotton");
            actGet("cue");
            _action("tie the cotton to the cue", act);
            break;
        case 2:
            actGet("maggot");
            _action("put the maggot on the needle", act);
            break;
        }
    }

    void run() override
    {
        IItem cotton = has("cotton");
        IItem cue = has("cue");
        IItem maggot = has("maggot");
        IItem needle = has("needle");

        // wont trigger after get dead fish because maggot is gone.
        if (cotton && cue && maggot && needle)
        {
            if (connected(cotton, cue))
            {
                if (relatedTo(maggot, needle))
                {
                    text("Maybe [put the needle into the moat](put the needle into the moat).");
                }
                else
                {
                    text("Maybe [put the maggot on the needle](do fish 2).");
                }
            }
            else
            {
                text("Maybe [tie cotton to cue](do fish 1).");
            }
        }
    }
};

struct PoisonPuzzle: public Puzzle
{
    PoisonPuzzle() : Puzzle("poison") {}

    void run() override
    {
        // you can also do this by dropping fish then drag poison to it.
        IItem poison = has("poison");
        IItem fish = has("dead fish");
        if (fish.carried() && poison.carried())
        {
            text("Maybe [put the rat poison on the fish](put the rat poison on the fish).");
        }
    }
};

static uchar* symFlagBear()
{
     static int addr;
     if (!addr) addr = get_sym_value("FlagBear");
     assert(addr);
     return getcode() + addr;
}

struct CubicCagePuzzle: public Puzzle
{
    CubicCagePuzzle() : Puzzle("cubic cage") {}

    void run() override
    {
        uchar* flagBear = symFlagBear();
        LOG4("Bear symbol",flagBear);
        if (*flagBear != 0x00)
        {
             if (state(0,1))
             {
                 _action("Look in cubic cage",1);
                 _res = false;
             }
        }
    }
};

struct WindowPuzzle: public Puzzle
{
    WindowPuzzle() : Puzzle("frosted window") {}

    void run() override
    {
        //IItem wnd("window");
        //if (!wnd.isBroken())
            text("Maybe [break the window](break the frosted window).");
    }
};

struct HorseshoePuzzle: public Puzzle
{
    HorseshoePuzzle() : Puzzle("horseshoe") {}

    void run() override
    {
        if (state(0,1))
            text("Maybe [rub the horseshoe](rub the horseshoe).", 1);
    }
};

struct LadderPuzzle: public Puzzle
{
    LadderPuzzle() : Puzzle("ladder") {}

    void run() override
    {
        IItem ladder(_name);
        IItem topWaterfall = IItem::getRoom(RNTPWFL); // top of waterfall
        if (relatedTo(ladder, topWaterfall))
        {
            text("Maybe [untie the ladder](untie the ladder).");
        }
    }
};

struct SandPuzzle: public Puzzle
{
    SandPuzzle() : Puzzle("sand") {}

    void run() override
    {
        IItem boots("boots");
        if (boots.isHidden())
            text("Maybe [dig in the sand](dig in sand).");
    }
};

struct ButtonPuzzle: public Puzzle
{
    ButtonPuzzle() : Puzzle("till button") {}

    void run() override
    {
        IItem till("till");
        if (till.isClosed())
            text("Maybe [press the button](press button).");
    }
};

struct MillPuzzle: public Puzzle
{
    MillPuzzle() : Puzzle("vanes") {}

    void run() override
    {
        IItem mill("mill");
        if (!mill.isInitialStateDone())
            text("Maybe [shout](shout to miller, stop mill) to the [miller], '_Stop the [mill]_'.");
    }
};

struct BedPuzzle: public Puzzle
{
    BedPuzzle() : Puzzle("king-size bed") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem pon(find_item(get_object_player_on()));
            if (pon)
            {
                text("No time to be lazy. Maybe [get off](get off bed) the bed.", 1);
            }
            else
            {
                text("The bed looks very comfortable. Maybe [sit](sit on bed) on it.", 1);
            }
        }
    }
};

struct WaxPuzzle: public Puzzle
{
    WaxPuzzle() : Puzzle("wax") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem mirror = has("mirror");
            IItem gem = has("gem");
            if (mirror.texture() == 10 && gem.isExplored()) // warm
            {
                text("Maybe [point mirror at wax](point mirror at wax).", 1);
            }
        }
    }
};

struct StatuePuzzle: public Puzzle
{
    StatuePuzzle() : Puzzle("statue") {}

    void run() override
    {
        if (get_current_room() == RNTEMPLE)  // only in temple room
            text("Maybe try [moving the statue](move the statue).");
    }
};

struct PalmTreePuzzle: public Puzzle
{
    PalmTreePuzzle() : Puzzle("palm tree") {}

    void run() override
    {
        if (state(0,1) && relatedTo("coconut", IItem(_name)))
        {
            text("Maybe [shake the tree](shake tree)", 1);
        }
    }
};

struct SarcophagusPuzzle: public Puzzle
{
    SarcophagusPuzzle() : Puzzle("sarcophagus") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem sarco("sarcophagus");
            IItem bone = has("finger bone");
            if (sarco.isLocked() && bone.carried())
            {
                text("Maybe [open](open sarcophagus with bone) the sarcophagus with the finger bone.", 1);
            }
        }
    }
};

struct CoconutPuzzle: public Puzzle
{
    CoconutPuzzle() : Puzzle("coconut") {}

    void run() override
    {
        IItem smspade = has("small spade");
        IItem coconut = has("coconut");
        if (coconut && !coconut.isBroken() && smspade.carried())
        {
            if (state(0,1))
            {
                text("Maybe [break](break the coconut with the small spade) the coconut with the small spade.", 1);
            }
        }
    }
};

struct FeetPuzzle: public Puzzle
{
    FeetPuzzle() : Puzzle("feet") {}

    void run() override
    {
        if ((get_current_room() == RNFNRM) || (get_current_room() == RNSTPS)) // Room of hot coals, Flight of steps
        {
            IItem succ = has("succulents");
            if (succ.carried())
            {
                if (state(0,1))
                {
                        text("Maybe [rub](rub succulents on feet) the succulents on your feet.", 1);
                }
            }
        }
    }
};

struct BoatPuzzle: public Puzzle
{
    BoatPuzzle() : Puzzle("rope") {}

    void run() override
    {
        if (state(0,1))
        {
            text("Maybe [pull](pull the rope) the rope.", 1);
        }
    }
};

struct RedDiePuzzle: public Puzzle
{
    RedDiePuzzle() : Puzzle("red die") {}

    void run() override
    {
        if (has(_name).carried() && state(0,1))
        {
            text("Hmm, it's a die. How about [rolling](roll red die) it?", 1);
        }
    }
};

struct GreenDiePuzzle: public Puzzle
{
    GreenDiePuzzle() : Puzzle("green die") {}

    void run() override
    {
        if (has(_name).carried() && state(0,1))
        {
            text("Hmm, it's a die. How about [rolling](roll green die) it?", 1);
        }
    }
};

struct BlueDiePuzzle: public Puzzle
{
    BlueDiePuzzle() : Puzzle("blue die") {}

    void run() override
    {
        if (has(_name).carried() && state(0,1))
        {
            text("Hmm, it's a die. How about [rolling](roll blue die) it?", 1);
        }
    }
};

struct YellowDiePuzzle: public Puzzle
{
    YellowDiePuzzle() : Puzzle("yellow die") {}

    void run() override
    {
        if (has(_name).carried() && state(0,1))
        {
            text("Hmm, it's a die. How about [rolling](roll yellow die) it?", 1);
        }
    }
};

struct SmallDoorPuzzle: public Puzzle
{
    SmallDoorPuzzle() : Puzzle("small door") {}

    void run() override
    {
        if (get_current_room() == RNCAGE)
        {
            IItem sd = has("small door");
            IItem mynah = has("mynah bird");
            if (sd.isOpen() && !mynah.isContained())
            {
                text("The mynah appears without ostentation, but is obviously staring at the open doorway. Better [close](close small door) the small [door]?", 1);
            }
        }
    }
};

struct GumPuzzle: public Puzzle
{
    GumPuzzle() : Puzzle("gum") {}

    void run() override
    {
        IItem gum = has(_name);

        // only offer to chew if not already
        if (gum.carried() && !gum.isIntrinsic()) 
        {
            if (state(0,1))
            {
                text("Need to think outside the [box]? Perhaps [chewing](chew gum) the gum helps?", 1);
            }
        }
    }
};

struct HoorayPuzzle: public Puzzle
{
    HoorayPuzzle() : Puzzle("hooray") {}
    
    bool precondition() override
    {
        return true;
    }

    void run() override
    {
        string cmd = "Say [Hooray](say hooray)?";
        if (has("mynah bird").carried())
        {
            // if you have the bottle and it's not been shaken
            IItem c = has("champagne");

            // fizzy champagne is warm when shaken, cold otherwise
            if (c && c.texture() != 10) 
            {
                cmd += " or [teach](say to mynah, hooray) the mynah to say it?";
            }
        }
        text(cmd.c_str());
    }
};
    
struct ShorterQueuePuzzle: public Puzzle
{
    ShorterQueuePuzzle() : Puzzle("shorter queue") {}

    void run() override
    {
        if (state(0,1))
        {
            text("maybe [join the shorter queue](join the shorter queue)?", 1);
        }
    }
};


struct LongerQueuePuzzle: public Puzzle
{
    LongerQueuePuzzle() : Puzzle("longer queue") {}

    void run() override
    {
        if (state(0,1))
        {
            text("Maybe [join the longer queue](join the longer queue)?", 1);
        }
    }
};


struct PlasticDiePuzzle: public Puzzle
{
    PlasticDiePuzzle() : Puzzle("plastic die") {}

    void run() override
    {
        if (has(_name).carried() && state(0,1))
        {
            text("Hmm, it's a die. How about [rolling](roll plastic die) it?", 1);
        }
    }
};

struct LutePuzzle: public Puzzle
{
    LutePuzzle() : Puzzle("lute") {}

    void action(int act) override
    {
        switch (act)
        {
        case 1:
            IItem lute = has("lute");
            if (lute)
            {
                actIsoGet(lute);
                _action("play lute");
            }
            break;
        }
    }

    void run() override
    {
        IItem lute = has("lute");
        IItem watercolour("watercolour");
        if (lute.carried())
        {
            if (state(0,1))
            {
                string txtout = "How about [playing](do lute 1) the [lute]?";
                if (watercolour.isExplored())
                {
                    // doing this before the bank showdown will disintregate the lute -> dead end
                    // perhaps allow this only after bank is blown up?
                    txtout = txtout + " Or even [sing](sing Urfanore Pendra), '_Urfanore [Pendra]_'?";
                }
                text(txtout.c_str(), 1);
            }

        }
    }
};

#if 0
struct BottlePuzzle: public Puzzle
{
    BottlePuzzle() : Puzzle("champagne bottle") {}

    void run() override
    {
        //IItem cbottle = has("champagne bottle");
        //if (get_current_room()==RNMANOFFIS)

        // first move must be examine to get the shake option
        _action("examine champagne bottle",1);
        _res = false;

        /*
        if (cbottle.carried() && cbottle.isClosed())
        {
            text("Do you want to [open](open champagne bottle) the bottle?", 1);
        }
        */
    }
};
#endif


struct PillarPuzzle: public TreasurePuzzle
{
    PillarPuzzle() : TreasurePuzzle("pillar") {}

    void run() override
    {
        if (state(0,1))
        {
            const IItems& t = treasure();
            bool tfound = false;
            for (size_t i = 0; i < t.size(); ++i)
            {
                if (!t[i].carried())
                {
                    tfound = true;
                    break;
                }
            }
            
            if (tfound)
            {
                text("Scattered around the pillar are your treasures. Maybe [pick](get all) them all up?", 1);
            }
        }
    }
};

struct MachinePuzzle: public Puzzle
{
    MachinePuzzle() : Puzzle("machine") {}

    void run() override
    {
        if (state(0,1))
        {
            IItem wm = has("weighing machine");
            IItem pd = has("pastic die");
            if (pd.isRelatedTo(wm.id()))
            {
                text("You could try being fast... or smart. [Get the cube](get cube) or [get the anticube](get anticube) "
                     " or [get the die](get plastic die) or [get the cube and the anticube](get cube and anticube) or "
                     " [get the cube and the die](get cube and die) or [get the die and the anticube](get die and anticube) "
                     "or [get all tree](get cube and anticube and die)?", 1);
            }
        }
    }
};
